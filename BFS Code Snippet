#include <bits/stdc++.h>
using namespace std;

const int M = 1505; // Maximum size
vector<int> E[M << 1]; // Adjacency list
int DEG[M << 1]; // In-degree array
bool VIS[M << 1]; // Visited array
queue<int> q; // BFS queue

// Function to add edges
inline void addE(int u, int v) {
    E[u].push_back(v);
    DEG[v]++;
}

// BFS function
bool bfs(int target) {
    for (int i = 1; i <= m + 1; i++) {
        if (DEG[i] == 0) q.push(i); // Initialize BFS with nodes of in-degree 0
    }
    
    while (!q.empty()) {
        int u = q.front(); q.pop(); // Get the front element
        if (u == target) return true; // Check if we reached the target
        
        // Process each adjacent node
        for (auto p : E[u]) {
            DEG[p]--; // Decrease in-degree of adjacent node
            if (DEG[p] == 0) {
                q.push(p); // Add to queue if in-degree becomes 0
            }
        }
    }
    return false; // Target not reached
}


namespace HASH {
	const int base = 1507, mod = 998244353;
	inline int gVal(int *P) {
		int res = 0;
		for(int i = 1; i <= m; i++) res = (1ll * res * base + P[i]) % mod;
		return res;
	}
}


DFS Function:

This snippet is useful for augmenting path searches in bipartite graphs:
cpp
Copy code
bool dfs(int now, int tg) {
    if (visT[now] == tg) return 0;
    visT[now] = tg;
    for (auto p : E[now]) {
        if (!mtch[p] || dfs(mtch[p], tg)) {
            mtch[p] = now;
            return 1;
        }
    }
    return 0;
}
Graph Initialization:

Use this snippet to initialize a 2D array representing a graph:
cpp
Copy code
for (int i = 1; i <= n; i++) 
    for (int j = 1; j <= n; j++) 
        G[i][j] = -1; // Initialize with -1 or another sentinel value
Fast Input/Output:

This is crucial for performance in competitive programming:
cpp
Copy code
ios::sync_with_stdio(0);
cin.tie(0), cout.tie(0);
Building Adjacency List:

Reuse this method for constructing an adjacency list from edges:
cpp
Copy code
for (int j = 1; j <= m; j++) 
    if (U[j] != i && V[j] != i) 
        E[U[j]].push_back(V[j]);
